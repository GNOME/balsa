requires 1.0.0

%h{
/*
 * Balsa E-Mail Client
 * Copyright (C) 1997-1999 Jay Painter and Stuart Parmenter
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option) 
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
 * 02111-1307, USA.
 */

#include "config.h"
#include <gnome.h>
#include "helper.h"
#include "balsa-initdruid.h"
#include "balsa-druid-page.h"
%}

%privateheader{
enum __ed_types {
	INBOX,
	OUTBOX,
	SENTBOX,
	DRAFTBOX,
	TRASH,
	NUM_EDs
};
%}

%{
#include "balsa-app.h"
#include "cfg-balsa.h"
#include "balsa-druid-page-error.h"
#include "misc.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

static gchar *init_mbnames[NUM_EDs] = { N_("Inbox:"), N_("Outbox:"), N_("Sentbox:"), N_("Draftbox:"), N_("Trash:") };

static Mailbox *unconditional_mailbox( const gchar *path, const gchar *prettyname, gchar **error );

static Mailbox *unconditional_mailbox( const gchar *path, const gchar *prettyname, gchar **error )
{
	struct stat sb;
	gchar *dup;
	gchar *index;
	int fd;
	MailboxType mt;
	Mailbox *box;

	if( (*error) != NULL )
		return NULL;

	dup = g_strdup( path );
	index = g_basename( dup );

	if( index == NULL ) {
		(*error) = g_strdup_printf( _("The pathname \"%s\" must be specified"
			" canonically -- it must start with a \'/\'."), dup );
		g_free( dup );
		return NULL;
	}

	index[-1] = '\0'; /*Split off the dirs from the file.*/

	if( balsa_init_create_to_directory( dup, error ) ) {
		/*TRUE->error*/
		g_free( dup );
		return NULL;
	}

	index[-1] = '/';

	if( stat( dup, &sb ) < 0 ) {
		if( (fd = creat( dup, S_IRUSR | S_IWUSR )) < 0 ) {
			(*error) = g_strdup_printf( _("An error occurred when attempting "
				"to creat(2) the file \"%s\"."), dup );
			g_free( dup );
			return NULL;
		}

		close( fd );
	} else if( mailbox_valid( dup ) == MAILBOX_UNKNOWN ) {
		(*error) = g_strdup_printf( _("The mailbox \"%s\" does not appear to be valid."),
			dup );
		g_free( dup );
		return NULL;
	}

	mt = mailbox_valid( dup );
	box = BALSA_MAILBOX( mailbox_new( mt ) );
	box->name = g_strdup( gettext( prettyname ) );
	(MAILBOX_LOCAL( box ))->path = dup;
	cfg_mailbox_write_simple( box );
	mailbox_add_for_checking( box );
	return box;
}

%}

class Balsa:Druid:Page:Directory from Balsa:Druid:Page {
	private GtkWidget *inbox;
	private GtkWidget *outbox;
	private GtkWidget *sentbox;
	private GtkWidget *draftbox;
	private GtkWidget *trash;
	private gboolean paths_locked;

	/*No arrays in gob :-(*/
	private EntryMaster emaster;
	private EntryData ed[NUM_EDs];

	public GtkObject *new( Balsa:InitDruid *druid (check type null ) ) 
	{ 
		GtkObject *self = GTK_OBJECT( GET_NEW );
		(BALSA_DRUID_PAGE( self ))->druid = GNOME_DRUID( druid );
		if( BALSA_DRUID_PAGE_CLASS( (GTK_OBJECT( self ))->klass )->construct )
			BALSA_DRUID_PAGE_CLASS( (GTK_OBJECT( self ))->klass )->construct( BALSA_DRUID_PAGE( self ) );
		return self;
	}

	init( self ) 
	{
		GtkTable *table;
		GtkLabel *label;
		int i;
		GtkWidget **init_widgets[NUM_EDs];
		gchar *init_presets[NUM_EDs] = { NULL, NULL, NULL, NULL, NULL };

		self->_priv->paths_locked = FALSE;

		self->_priv->emaster.setbits = 0;
		self->_priv->emaster.numentries = 0;
		self->_priv->emaster.donemask = 0;

		table = GTK_TABLE( gtk_table_new( NUM_EDs + 1, 2, FALSE ) );
	
		label = GTK_LABEL( gtk_label_new( _(
			"Please verify the locations of your default mail files.\n"
			"These will be created if necessary." ) ) );
		gtk_label_set_justify( label, GTK_JUSTIFY_RIGHT );
		gtk_label_set_line_wrap( label, TRUE );

		gtk_table_attach( table, GTK_WIDGET( label ), 0, 2, 0, 1,
			GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL,
			8, 4 );

		init_presets[INBOX] = balsa_guess_mail_spool();

		init_widgets[INBOX] = &( self->_priv->inbox );
		init_widgets[OUTBOX] = &( self->_priv->outbox );
		init_widgets[SENTBOX] = &( self->_priv->sentbox );
		init_widgets[DRAFTBOX] = &( self->_priv->draftbox );
		init_widgets[TRASH] = &( self->_priv->trash );

		for( i = 0; i < NUM_EDs; i++ ) {
			gchar *preset;

			self->_priv->ed[i].master = &( self->_priv->emaster );

			init_mbnames[i] = _(init_mbnames[i]);

			if( init_presets[i] )
				preset = init_presets[i];
			else
				preset = g_strdup( "[Dummy value]" );

			balsa_init_add_table_entry( table, i, init_mbnames[i], preset,
				&( self->_priv->ed[i] ), GTK_WIDGET( self ), init_widgets[i] );

			g_free( preset );
		}

		gtk_box_pack_start( GTK_BOX( (GNOME_DRUID_PAGE_STANDARD( self ))->vbox ),
			GTK_WIDGET( table ), TRUE, TRUE, 8 );
		gtk_widget_show_all( GTK_WIDGET( table ) );
	}

	override (Balsa:Druid:Page) void
	construct( Balsa:Druid:Page *self ) 
	{
		(GNOME_DRUID_PAGE_STANDARD( self ))->title = g_strdup( _("Mail Files" ) );

		g_return_if_fail( (BALSA_DRUID_PAGE( self ))->druid != NULL );
		(GNOME_DRUID_PAGE_STANDARD( self ))->logo_image = (BALSA_INITDRUID( (BALSA_DRUID_PAGE( self ))->druid ))->default_logo;

		PARENT_HANDLER( self );
	}

	override (Gnome:Druid:Page) void
	prepare( Gnome:Druid:Page *_self, Gtk:Widget *druid (check type null) ) 
	{
		gchar *buf;
		BalsaDruidPageDirectory *self = BALSA_DRUID_PAGE_DIRECTORY( _self );

		/* We want a change in the local mailroot to be reflected in the directories
		 * here, but we don't want to trash user's custom settings if needed. Hence
		 * the paths_locked variable; it should work pretty well, because only a movement
		 * backwards should change the mailroot; going forward should not lock the paths:
		 * envision an error occurring; upon return to the Dir page the entries should be
		 * the same. 
		 */

		if( !self->_priv->paths_locked ) {
			buf = g_strconcat( balsa_app.local_mail_directory, "/outbox", NULL );
			gtk_entry_set_text( GTK_ENTRY( self->_priv->outbox ), buf );
			g_free( buf );

			buf = g_strconcat( balsa_app.local_mail_directory, "/sentbox", NULL );
			gtk_entry_set_text( GTK_ENTRY( self->_priv->sentbox ), buf );
			g_free( buf );

			buf = g_strconcat( balsa_app.local_mail_directory, "/draftbox", NULL );
			gtk_entry_set_text( GTK_ENTRY( self->_priv->draftbox ), buf );
			g_free( buf );

			buf = g_strconcat( balsa_app.local_mail_directory, "/trash", NULL );
			gtk_entry_set_text( GTK_ENTRY( self->_priv->trash ), buf );
			g_free( buf );
		}

		/* Don't let them continue unless all entries have something. */
		if( ENTRY_MASTER_DONE( self->_priv->emaster ) ) {
			gnome_druid_set_buttons_sensitive( GNOME_DRUID( druid ), TRUE, TRUE, TRUE );
		} else {
			gnome_druid_set_buttons_sensitive( GNOME_DRUID( druid ), TRUE, FALSE, TRUE );
		}

		gnome_druid_set_show_finish( GNOME_DRUID( druid ), FALSE );
	}

	override (Gnome:Druid:Page) gboolean
	next( Gnome:Druid:Page *_self, Gtk:Widget *druid (check type null) ) 
	{
		gchar *error = NULL;
		BalsaDruidPageDirectory *self = BALSA_DRUID_PAGE_DIRECTORY( _self );	

		balsa_app.inbox = unconditional_mailbox( gtk_entry_get_text( GTK_ENTRY( self->_priv->inbox ) ),
			"Inbox", &error );
		balsa_app.outbox = unconditional_mailbox( gtk_entry_get_text( GTK_ENTRY( self->_priv->outbox ) ),
			"Outbox", &error );
		balsa_app.sentbox = unconditional_mailbox( gtk_entry_get_text( GTK_ENTRY( self->_priv->sentbox ) ),
			"Sentbox", &error );
		balsa_app.draftbox = unconditional_mailbox( gtk_entry_get_text( GTK_ENTRY( self->_priv->draftbox ) ),
			"Draftbox", &error );
		balsa_app.trash = unconditional_mailbox( gtk_entry_get_text( GTK_ENTRY( self->_priv->trash ) ),
			"Trash", &error );

		self->_priv->paths_locked = TRUE;

		if( error ) {
			BalsaDruidPageError *ep;

			ep = BALSA_DRUID_PAGE_ERROR( balsa_druid_page_error_new_after( BALSA_DRUID_PAGE( self ),
				_("Problem Creating Mailboxes"), error ) );
			g_free( error );
			balsa_druid_page_error_goto_me( ep );
		} else {
			PARENT_HANDLER( _self, druid );
		}

		return TRUE;
	}

	override (Gnome:Druid:Page) gboolean
	back( Gnome:Druid:Page *_self, Gtk:Widget *druid (check type null) ) 
	{
		BalsaDruidPageDirectory *self = BALSA_DRUID_PAGE_DIRECTORY( _self );	
		
		self->_priv->paths_locked = FALSE;
		PARENT_HANDLER( _self, druid );
		return TRUE;
	}

}

%h{
/*
 * Balsa E-Mail Client
 * Copyright (C) 1997-1999 Jay Painter and Stuart Parmenter
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option) 
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
 * 02111-1307, USA.
 */

#include "config.h"
#include <gnome.h>
#include "helper.h"
#include "balsa-initdruid.h"
#include "balsa-druid-page.h"

%}

%{
#include <sys/types.h>
#include <sys/stat.h>

#include "balsa-druid-page-error.h"
#include "balsa-app.h"
#include "balsa-identity.h"
%}

class Balsa:Druid:Page:User from Balsa:Druid:Page {
	private GtkWidget *name;
	private GtkWidget *email;
	private GtkWidget *smtp;
	private GtkWidget *localmaildir;
	private EntryMaster emaster;
	/* Gob can't handle arrays. Sigh. */
	private EntryData ed0;
	private EntryData ed1;
	private EntryData ed2;
	private EntryData ed3;

	public GtkObject *new( Balsa:InitDruid *druid (check type null ) ) 
	{ 
		GtkObject *self = GTK_OBJECT( GET_NEW );
		(BALSA_DRUID_PAGE( self ))->druid = GNOME_DRUID( druid );
		if( BALSA_DRUID_PAGE_CLASS( (GTK_OBJECT( self ))->klass )->construct )
			BALSA_DRUID_PAGE_CLASS( (GTK_OBJECT( self ))->klass )->construct( BALSA_DRUID_PAGE( self ) );
		return self;
	}

	init( self ) {
		GtkTable *table;
		GtkLabel *label;
		gchar *preset;
		char hostbuf[512];

		self->_priv->emaster.setbits = 0;
		self->_priv->emaster.numentries = 0;
		self->_priv->emaster.donemask = 0;
		self->_priv->ed0.master = &( self->_priv->emaster );
		self->_priv->ed1.master = &( self->_priv->emaster );
		self->_priv->ed2.master = &( self->_priv->emaster );
#if ENABLE_ESMTP
		self->_priv->ed3.master = &( self->_priv->emaster );

		table = GTK_TABLE( gtk_table_new( 5, 2, FALSE ) );
#else
		table = GTK_TABLE( gtk_table_new( 4, 2, FALSE ) );
#endif


		label = GTK_LABEL( gtk_label_new( _("Please enter information about yourself.") ) );
		gtk_label_set_justify( label, GTK_JUSTIFY_CENTER );
		gtk_label_set_line_wrap( label, TRUE );
		gtk_table_attach( table, GTK_WIDGET( label ), 0, 2, 0, 1,
			GTK_EXPAND | GTK_FILL, GTK_EXPAND | GTK_FILL, 
			8, 4 );

		preset = g_get_real_name();
		balsa_init_add_table_entry( table, 0, _("Name:"), preset, &( self->_priv->ed0 ), GTK_WIDGET( self ), &( self->_priv->name ) );
		
		gethostname( hostbuf, 511 );
		preset = g_strconcat( g_get_user_name(), "@", hostbuf, NULL );
		balsa_init_add_table_entry( table, 1, _("Email address:"), preset, &( self->_priv->ed1 ), GTK_WIDGET( self ), &( self->_priv->email ) );
		g_free( preset );

		preset = g_strconcat( g_get_home_dir(), "/mail", NULL );
		balsa_init_add_table_entry( table, 2, _("Local Mail Directory:"), preset, &(self->_priv->ed2 ), GTK_WIDGET( self ), &( self->_priv->localmaildir ) );
		g_free( preset );

#if ENABLE_ESMTP
		preset = "localhost:25";
		balsa_init_add_table_entry( table, 3, _("SMTP Server:"), preset, &( self->_priv->ed3 ), GTK_WIDGET( self ), &( self->_priv->smtp ) );
#endif

		gtk_box_pack_start( GTK_BOX( (GNOME_DRUID_PAGE_STANDARD( self ))->vbox ),
			GTK_WIDGET( table ), TRUE, TRUE, 8 );
		gtk_widget_show_all( GTK_WIDGET( table ) );
	}

	override (Balsa:Druid:Page) void
	construct( Balsa:Druid:Page *self ) {
		(GNOME_DRUID_PAGE_STANDARD( self ))->title = g_strdup( _("User Settings" ) );

		g_return_if_fail( (BALSA_DRUID_PAGE( self ))->druid != NULL );
		(GNOME_DRUID_PAGE_STANDARD( self ))->logo_image = (BALSA_INITDRUID( (BALSA_DRUID_PAGE( self ))->druid ))->default_logo;

		PARENT_HANDLER( self );
	}

	override (Gnome:Druid:Page) void
	prepare( Gnome:Druid:Page *_self, Gtk:Widget *druid (check type null) ) {
		BalsaDruidPageUser *self = BALSA_DRUID_PAGE_USER( _self );

		/* Don't let them continue unless all entries have something. */
		/* FIXME: unify this with code above */

		if( ENTRY_MASTER_DONE( self->_priv->emaster ) ) {
			gnome_druid_set_buttons_sensitive( GNOME_DRUID( druid ), TRUE, TRUE, TRUE );
		} else {
			gnome_druid_set_buttons_sensitive( GNOME_DRUID( druid ), TRUE, FALSE, TRUE );
		}

		gnome_druid_set_show_finish( GNOME_DRUID( druid ), FALSE );
	}

	override (Gnome:Druid:Page) gboolean
	next( Gnome:Druid:Page *_self, Gtk:Widget *druid (check type null) ) {
		gchar *uhoh;
		BalsaDruidPageUser *self = BALSA_DRUID_PAGE_USER( _self );
		BalsaIdentity* ident;
		
		if (balsa_app.identities == NULL) {
			ident = BALSA_IDENTITY(balsa_identity_new());
			balsa_app.identities = g_list_append(balsa_app.identities, ident);
		} else {
			ident = balsa_app.current_ident;
		}
		if( ident->address->full_name )
			g_free( ident->address->full_name );
		ident->address->full_name = g_strdup( gtk_entry_get_text( GTK_ENTRY( self->_priv->name ) ) );

		if( ident->address->address_list ) {
			g_list_foreach(ident->address->address_list, (GFunc)g_free, NULL);
			g_list_free(ident->address->address_list);
			ident->address->address_list = NULL;
		}
		ident->address->address_list = g_list_append(ident->address->address_list, 
								g_strdup( gtk_entry_get_text( GTK_ENTRY( self->_priv->email ) ) ) );

#if ENABLE_ESMTP
		if( balsa_app.smtp_server );
			g_free( balsa_app.smtp_server );
		balsa_app.smtp_server = g_strdup( gtk_entry_get_text( GTK_ENTRY( self->_priv->smtp ) ) );
#endif
		if( balsa_app.local_mail_directory );
			g_free( balsa_app.local_mail_directory );
		balsa_app.local_mail_directory = g_strdup( gtk_entry_get_text( GTK_ENTRY( self->_priv->localmaildir ) ) );

		if( balsa_init_create_to_directory( balsa_app.local_mail_directory, &uhoh ) ) {
			GtkObject *page;

			page = balsa_druid_page_error_new_after( BALSA_DRUID_PAGE( self ), _("Local Mail Problem"), uhoh );
			g_free( uhoh );
			balsa_druid_page_error_goto_me( BALSA_DRUID_PAGE_ERROR( page ) );
		} else {
			PARENT_HANDLER( _self, druid );
		}

		balsa_identity_set_current(ident);
		return TRUE;
	}
}

/* Generated by GOB (v0.90.5) on Sun Dec  5 18:12:27 1999
   (do not edit directly) */

#include "balsa-druid-page.h"

static void balsa_druid_page_init (BalsaDruidPage *o);
static void balsa_druid_page_class_init (BalsaDruidPageClass *c);
static gboolean balsa_druid_page_next (GnomeDruidPage *_self, GtkWidget *druid);
static gboolean balsa_druid_page_back (GnomeDruidPage *_self, GtkWidget *druid);

static GnomeDruidPageStandardClass *parent_class = NULL;

guint
balsa_druid_page_get_type (void)
{
	static guint type = 0;

	if (!type) {
		static const GtkTypeInfo info = {
			"BalsaDruidPage",
			sizeof (BalsaDruidPage),
			sizeof (BalsaDruidPageClass),
			(GtkClassInitFunc) balsa_druid_page_class_init,
			(GtkObjectInitFunc) balsa_druid_page_init,
			/* reserved_1 */ NULL,
			/* reserved_2 */ NULL,
			(GtkClassInitFunc) NULL,
		};

		type = gtk_type_unique (gnome_druid_page_standard_get_type(), &info);
	}

	return type;
}


static GtkObject *(* new) (void) = balsa_druid_page_new;

#define GET_NEW (gtk_type_new(balsa_druid_page_get_type()))
static void 
balsa_druid_page_init (BalsaDruidPage *o)
{
return;
}
static void 
balsa_druid_page_class_init (BalsaDruidPageClass *c)
{
	GnomeDruidPageClass *gnome_druid_page_class = (GnomeDruidPageClass *)c;

	parent_class = gtk_type_class (gnome_druid_page_standard_get_type ());

	gnome_druid_page_class->next = balsa_druid_page_next;
	gnome_druid_page_class->back = balsa_druid_page_back;
return;
}



#line 32 "balsa-druid-page.gob"
GtkObject *
balsa_druid_page_new (void)
{
	{
#line 32 "balsa-druid-page.gob"
		 GtkObject *me; me = GTK_OBJECT( GET_NEW ); return me; 
#line 67 "balsa-druid-page.c"
	}
}

#line 34 "balsa-druid-page.gob"
static gboolean 
balsa_druid_page_next (GnomeDruidPage *_self, GtkWidget *druid)
#define PARENT_HANDLER(args...) \
	{ if(GNOME_DRUID_PAGE_CLASS(parent_class)->next) \
		(* GNOME_DRUID_PAGE_CLASS(parent_class)->next)(##args); }
{
	g_return_val_if_fail (druid != NULL, (gboolean )0);
	g_return_val_if_fail (GTK_IS_WIDGET (druid), (gboolean )0);
	{
#line 35 "balsa-druid-page.gob"
		
		BalsaDruidPage *self = BALSA_DRUID_PAGE( _self );
		g_return_val_if_fail( self->next != NULL, FALSE );
		if( BALSA_IS_DRUID_PAGE( self->next ) ) {
			(BALSA_DRUID_PAGE(self->next))->prev = GNOME_DRUID_PAGE( self );
		}
		gnome_druid_set_page( GNOME_DRUID( druid ), self->next );
		return TRUE;
	
#line 91 "balsa-druid-page.c"
	}
}
#undef PARENT_HANDLER

#line 45 "balsa-druid-page.gob"
static gboolean 
balsa_druid_page_back (GnomeDruidPage *_self, GtkWidget *druid)
#define PARENT_HANDLER(args...) \
	{ if(GNOME_DRUID_PAGE_CLASS(parent_class)->back) \
		(* GNOME_DRUID_PAGE_CLASS(parent_class)->back)(##args); }
{
	g_return_val_if_fail (druid != NULL, (gboolean )0);
	g_return_val_if_fail (GTK_IS_WIDGET (druid), (gboolean )0);
	{
#line 46 "balsa-druid-page.gob"
		
		BalsaDruidPage *self = BALSA_DRUID_PAGE( _self );
		g_return_val_if_fail( self->prev != NULL, FALSE ); /*This should always be set.*/
		if( BALSA_IS_DRUID_PAGE( self->prev ) ) {
			(BALSA_DRUID_PAGE(self->prev))->next = GNOME_DRUID_PAGE( self );
		}
		gnome_druid_set_page( GNOME_DRUID( druid ), self->prev );
		return TRUE;
	
#line 116 "balsa-druid-page.c"
	}
}
#undef PARENT_HANDLER
#undef GET_NEW


/*REALLY BAD HACK
  This is to avoid unused warnings if you don't call
  some method, it pollutes the namespace but the call
  is weird enough.  I need to find a better way to do
  this */
void __balsa_druid_page_really_bad_hack_to_avoid_warnings(void);
void
__balsa_druid_page_really_bad_hack_to_avoid_warnings(void)
{
	((void (*)(void))new)();
}


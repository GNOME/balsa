/* Generated by GOB (v0.90.5) on Tue Dec 21 17:43:57 1999
   (do not edit directly) */

#include "balsa-druid-page.h"


#line 28 "balsa-druid-page.gob"

#include "balsa-druid-page-welcome.h"

#line 12 "balsa-druid-page.c"
static void balsa_druid_page_init (BalsaDruidPage *o);
static void balsa_druid_page_class_init (BalsaDruidPageClass *c);
static void _real_balsa_druid_page_construct (BalsaDruidPage *self);
static void balsa_druid_page_construct (BalsaDruidPage *self);
static gboolean balsa_druid_page_next (GnomeDruidPage *_self, GtkWidget *druid);
static gboolean balsa_druid_page_back (GnomeDruidPage *_self, GtkWidget *druid);

static GnomeDruidPageStandardClass *parent_class = NULL;

guint
balsa_druid_page_get_type (void)
{
	static guint type = 0;

	if (!type) {
		static const GtkTypeInfo info = {
			"BalsaDruidPage",
			sizeof (BalsaDruidPage),
			sizeof (BalsaDruidPageClass),
			(GtkClassInitFunc) balsa_druid_page_class_init,
			(GtkObjectInitFunc) balsa_druid_page_init,
			/* reserved_1 */ NULL,
			/* reserved_2 */ NULL,
			(GtkClassInitFunc) NULL,
		};

		type = gtk_type_unique (gnome_druid_page_standard_get_type(), &info);
	}

	return type;
}


static void (* construct) (BalsaDruidPage *self) = balsa_druid_page_construct;

#define GET_NEW (gtk_type_new(balsa_druid_page_get_type()))
static void 
balsa_druid_page_init (BalsaDruidPage *o)
{
return;
}
static void 
balsa_druid_page_class_init (BalsaDruidPageClass *c)
{
	GnomeDruidPageClass *gnome_druid_page_class = (GnomeDruidPageClass *)c;

	parent_class = gtk_type_class (gnome_druid_page_standard_get_type ());

	c->construct = _real_balsa_druid_page_construct;
	gnome_druid_page_class->next = balsa_druid_page_next;
	gnome_druid_page_class->back = balsa_druid_page_back;
return;
}



#line 40 "balsa-druid-page.gob"
static void 
balsa_druid_page_construct (BalsaDruidPage *self)
#line 72 "balsa-druid-page.c"
{
	BalsaDruidPageClass *klass;
	g_return_if_fail (self != NULL);
	g_return_if_fail (BALSA_IS_DRUID_PAGE (self));
	klass = BALSA_DRUID_PAGE_CLASS(GTK_OBJECT(self)->klass);

	if(klass->construct)
		(*klass->construct)(self);
}
#line 40 "balsa-druid-page.gob"
static void 
_real_balsa_druid_page_construct (BalsaDruidPage *self)
{
#line 41 "balsa-druid-page.gob"
		
		GnomeDruidPageStandard *std = GNOME_DRUID_PAGE_STANDARD( self );

		std->background_item = gnome_canvas_item_new( gnome_canvas_root( GNOME_CANVAS( std->canvas ) ),
			GNOME_TYPE_CANVAS_RECT, NULL );

		std->logoframe_item = gnome_canvas_item_new( gnome_canvas_root( GNOME_CANVAS( std->canvas ) ),
			GNOME_TYPE_CANVAS_RECT, NULL );

		std->logo_item = gnome_canvas_item_new( gnome_canvas_root( GNOME_CANVAS( std->canvas ) ),
			GNOME_TYPE_CANVAS_IMAGE, NULL );
		if( std->logo_image )
			gnome_canvas_item_set( std->logo_item, "image", std->logo_image, NULL );

		std->title_item = gnome_canvas_item_new( gnome_canvas_root( GNOME_CANVAS( std->canvas ) ),
			GNOME_TYPE_CANVAS_TEXT, 
			"text", std->title,
			"font", "-adobe-helvetica-bold-r-normal-*-*-180-*-*-p-*-iso8859-1",
			"x", (gfloat) 15.0,
			"y", (gfloat) 8 + 50.0 / 2.0,
			"anchor", GTK_ANCHOR_WEST,
			NULL );
		
		/*FIXME: don't make these copied straight out of the druid code. */
		/*gnome_canvas_item_set( std->title_item, "x", 15.0, "y", (gfloat) 8 + 50.0 / 2.0, "anchor", GTK_ANCHOR_NORTH_WEST, NULL );*/
	
#line 113 "balsa-druid-page.c"
}

#line 68 "balsa-druid-page.gob"
static gboolean 
balsa_druid_page_next (GnomeDruidPage *_self, GtkWidget *druid)
#define PARENT_HANDLER(args...) \
	{ if(GNOME_DRUID_PAGE_CLASS(parent_class)->next) \
		(* GNOME_DRUID_PAGE_CLASS(parent_class)->next)(##args); }
{
	g_return_val_if_fail (druid != NULL, (gboolean )0);
	g_return_val_if_fail (GTK_IS_WIDGET (druid), (gboolean )0);
	{
#line 69 "balsa-druid-page.gob"
		
		BalsaDruidPage *self = BALSA_DRUID_PAGE( _self );

		self->druid = GNOME_DRUID( druid );

		g_return_val_if_fail( self->next != NULL, FALSE );

		if( BALSA_IS_DRUID_PAGE( self->next ) ) {
			(BALSA_DRUID_PAGE(self->next))->prev = GNOME_DRUID_PAGE( self );
		}

		gnome_druid_set_page( GNOME_DRUID( druid ), self->next );
		return TRUE;
	
#line 141 "balsa-druid-page.c"
	}
}
#undef PARENT_HANDLER

#line 84 "balsa-druid-page.gob"
static gboolean 
balsa_druid_page_back (GnomeDruidPage *_self, GtkWidget *druid)
#define PARENT_HANDLER(args...) \
	{ if(GNOME_DRUID_PAGE_CLASS(parent_class)->back) \
		(* GNOME_DRUID_PAGE_CLASS(parent_class)->back)(##args); }
{
	g_return_val_if_fail (druid != NULL, (gboolean )0);
	g_return_val_if_fail (GTK_IS_WIDGET (druid), (gboolean )0);
	{
#line 85 "balsa-druid-page.gob"
		
		BalsaDruidPage *self = BALSA_DRUID_PAGE( _self );

		self->druid = GNOME_DRUID( druid );

		g_return_val_if_fail( self->prev != NULL, FALSE ); /*This should always be set.*/

		if( BALSA_IS_DRUID_PAGE( self->prev ) ) {
			(BALSA_DRUID_PAGE(self->prev))->next = GNOME_DRUID_PAGE( self );
		} else if( BALSA_IS_DRUID_PAGE_WELCOME( self->prev ) ) {
			(BALSA_DRUID_PAGE_WELCOME(self->prev))->next = GNOME_DRUID_PAGE( self );
		}

		gnome_druid_set_page( GNOME_DRUID( druid ), self->prev );
		return TRUE;
	
#line 173 "balsa-druid-page.c"
	}
}
#undef PARENT_HANDLER
#undef GET_NEW


/*REALLY BAD HACK
  This is to avoid unused warnings if you don't call
  some method, it pollutes the namespace but the call
  is weird enough.  I need to find a better way to do
  this */
void __balsa_druid_page_really_bad_hack_to_avoid_warnings(void);
void
__balsa_druid_page_really_bad_hack_to_avoid_warnings(void)
{
	((void (*)(void))construct)();
}


/* Generated by GOB (v0.91.2) on Wed Dec 29 11:41:21 1999
   (do not edit directly) */

#include "balsa-initdruid.h"

#include "balsa-initdruid-private.h"


#line 27 "balsa-initdruid.gob"

#include "save-restore.h" 

#include "balsa-druid-page.h"
#include "balsa-druid-page-welcome.h"
#include "balsa-druid-page-user.h"
#include "balsa-druid-page-directory.h"
#include "balsa-druid-page-finish.h"

static void really_cb( gint reply, BalsaInitDruid *druid );

static void really_cb( gint reply, BalsaInitDruid *druid )
{
    if( reply == GNOME_YES ) {
	balsa_initdruid_finished( druid );
	gtk_exit( 0 );
    }
}


#line 31 "balsa-initdruid.c"
static void balsa_initdruid_class_init (BalsaInitDruidClass *c);
static void balsa_initdruid_init (BalsaInitDruid *self);
static void balsa_initdruid_cancel (GnomeDruid *_self);
static void balsa_initdruid_destroy (GtkObject *o);

static GnomeDruidClass *parent_class = NULL;

guint
balsa_initdruid_get_type (void)
{
	static guint type = 0;

	if (!type) {
		static const GtkTypeInfo info = {
			"BalsaInitDruid",
			sizeof (BalsaInitDruid),
			sizeof (BalsaInitDruidClass),
			(GtkClassInitFunc) balsa_initdruid_class_init,
			(GtkObjectInitFunc) balsa_initdruid_init,
			/* reserved_1 */ NULL,
			/* reserved_2 */ NULL,
			(GtkClassInitFunc) NULL,
		};

		type = gtk_type_unique (gnome_druid_get_type(), &info);
	}

	return type;
}


static GtkObject *(* new) (GtkWindow *window) = balsa_initdruid_new;
static void (* finished) (BalsaInitDruid *self) = balsa_initdruid_finished;

#define GET_NEW (gtk_type_new(balsa_initdruid_get_type()))
static void 
balsa_initdruid_class_init (BalsaInitDruidClass *c)
{
	GnomeDruidClass *gnome_druid_class = (GnomeDruidClass *)c;
	GtkObjectClass *gtk_object_class = (GtkObjectClass *)c;

	parent_class = gtk_type_class (gnome_druid_get_type ());

	gnome_druid_class->cancel = balsa_initdruid_cancel;
	gtk_object_class->destroy = balsa_initdruid_destroy;
return;
}
#line 67 "balsa-initdruid.gob"
static void 
balsa_initdruid_init (BalsaInitDruid *self)
#line 82 "balsa-initdruid.c"
{
	self->_priv = g_new0 (BalsaInitDruidPrivate,1);
 {
#line 67 "balsa-initdruid.gob"

		self->default_logo = balsa_init_get_png( "balsa-logo.png" );
		self->_priv->welcome = GTK_WIDGET( balsa_druid_page_welcome_new( self ) );
		gnome_druid_append_page( GNOME_DRUID( self ), GNOME_DRUID_PAGE( self->_priv->welcome ) );
	        gnome_druid_set_page( GNOME_DRUID( self ), GNOME_DRUID_PAGE( self->_priv->welcome ) );

		self->_priv->user = GTK_WIDGET( balsa_druid_page_user_new( self ) );
		gnome_druid_append_page( GNOME_DRUID( self ), GNOME_DRUID_PAGE( self->_priv->user ) );

		self->_priv->std_boxes = GTK_WIDGET( balsa_druid_page_directory_new( self ) );
		gnome_druid_append_page( GNOME_DRUID( self ), GNOME_DRUID_PAGE( self->_priv->std_boxes ) );

		self->_priv->finish = GTK_WIDGET( balsa_druid_page_finish_new() );
		gnome_druid_append_page( GNOME_DRUID( self ), GNOME_DRUID_PAGE( self->_priv->finish ) );

		(BALSA_DRUID_PAGE_WELCOME( self->_priv->welcome ))->next = GNOME_DRUID_PAGE( self->_priv->user );
		(BALSA_DRUID_PAGE( self->_priv->user ))->next = GNOME_DRUID_PAGE( self->_priv->std_boxes );
		(BALSA_DRUID_PAGE( self->_priv->std_boxes ))->next = GNOME_DRUID_PAGE( self->_priv->finish );
	
#line 106 "balsa-initdruid.c"
 }
}


#line 57 "balsa-initdruid.gob"
GtkObject *
balsa_initdruid_new (GtkWindow *window)
{
	g_return_val_if_fail (GTK_IS_WINDOW (window), (GtkObject *)0);
	g_return_val_if_fail (window != NULL, (GtkObject *)0);
	{
#line 57 "balsa-initdruid.gob"
		 
		GtkObject *self = GTK_OBJECT( GET_NEW );

		BALSA_INITDRUID(self)->_priv->window = GTK_WIDGET(window);
		gtk_object_ref( GTK_OBJECT( window ) );
		gtk_container_add( GTK_CONTAINER(BALSA_INITDRUID(self)->_priv->window), GTK_WIDGET(self));

		return self;
	 
#line 128 "balsa-initdruid.c"
	}
}


#line 87 "balsa-initdruid.gob"
static void 
balsa_initdruid_cancel (GnomeDruid *_self)
#define PARENT_HANDLER(args...) \
	{ if(GNOME_DRUID_CLASS(parent_class)->cancel) \
		(* GNOME_DRUID_CLASS(parent_class)->cancel)(##args); }
{
	{
#line 88 "balsa-initdruid.gob"
		
		GtkWidget *dialog;

		dialog = gnome_question_dialog_modal( _("This will exit Balsa. Do you\n"
				        "really want to do this?"), 
				 	(GnomeReplyCallback) really_cb, _self );
    		gnome_dialog_run( GNOME_DIALOG( dialog ) );
	
#line 150 "balsa-initdruid.c"
	}
}
#undef PARENT_HANDLER

#line 97 "balsa-initdruid.gob"
void 
balsa_initdruid_finished (BalsaInitDruid *self)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (BALSA_IS_INITDRUID (self));
	{
#line 97 "balsa-initdruid.gob"
		
		GtkObject *win;

		win = GTK_OBJECT( self->_priv->window );

		gtk_object_destroy( GTK_OBJECT( self->_priv->welcome ) );
		gtk_object_destroy( GTK_OBJECT( self->_priv->user ) );
		gtk_object_destroy( GTK_OBJECT( self->_priv->std_boxes ) );
		gtk_object_destroy( GTK_OBJECT( self->_priv->finish ) );
		gtk_object_destroy( GTK_OBJECT( self ) );
		/*gtk_object_unref( win );*/
		gtk_object_destroy( win );

		gtk_main_quit();
		/*config_global_save(); When cancelling this makes us coredump */
	
#line 179 "balsa-initdruid.c"
	}
}

#line 0 "balsa-initdruid.gob"
static void 
balsa_initdruid_destroy (GtkObject *o)
#define PARENT_HANDLER(args...) \
	{ if(GTK_OBJECT_CLASS(parent_class)->destroy) \
		(* GTK_OBJECT_CLASS(parent_class)->destroy)(##args); }
{
	g_free (BALSA_INITDRUID (o)->_priv);
	BALSA_INITDRUID (o)->_priv = NULL;
	{
#line 0 "balsa-initdruid.gob"
		PARENT_HANDLER (o);

#line 196 "balsa-initdruid.c"
	}
}
#undef PARENT_HANDLER
#undef GET_NEW


/*REALLY BAD HACK
  This is to avoid unused warnings if you don't call
  some method, it pollutes the namespace but the call
  is weird enough.  I need to find a better way to do
  this */
void __balsa_initdruid_really_bad_hack_to_avoid_warnings(void);
void
__balsa_initdruid_really_bad_hack_to_avoid_warnings(void)
{
	((void (*)(void))new)();
	((void (*)(void))finished)();
}


%alltop{
/* Balsa E-Mail Client
 * Copyright (C) 1998-1999 Jay Painter and Stuart Parmenter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option) 
 * any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
 * GNU General Public License for more details.
 *  
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
 * 02111-1307, USA.
 */
%}

%h{
#include "config.h"
#include <gnome.h>
#include "libbalsa.h"
#include "balsa-icons.h"
%}

%{

#include <gtk/gtkfeatures.h>
#include <string.h>
#include <gdk/gdkprivate.h>

#include "balsa-app.h"
#include "balsa-icons.h"
#include "balsa-mblist.h"
#include "balsa-mblist-private.h"
#include "mblist-window.h" /* mblist_open_mailbox */
#include "misc.h"
#include "mailbox.h"
#include "cfg-memory-widgets.h"

%}

%{

static gboolean
mailbox_nodes_to_ctree( GtkCTree * ctree,
			guint depth,
			GNode * gnode,
			GtkCTreeNode * cnode,
			gpointer data );

static void
check_new( GtkCTree *ctree, GtkCTreeNode *node, gpointer data );

static void 
mailbox_style (GtkCTree * ctree, GtkCTreeNode *node, MailboxNode *mbnode, gboolean display_info );

static void 
folder_style (GtkCTree* ctree, GtkCTreeNode* node, gpointer data);

#ifdef BALSA_SHOW_INFO
static gint
numeric_compare (GtkCList * clist, gconstpointer ptr1, gconstpointer ptr2);
#endif

static gint
mblist_mbnode_compare (gconstpointer a, gconstpointer b);

static GdkFont* 
get_bold_font (GtkWidget* widget);

%}

class Balsa:MBList from Gtk:CTree {
	private GList *watched_mailbox; /* list of mailboxes watched */
	private GtkStyle *unread_mailbox_style; /* store the style of unread mailboxes */
	
	public gboolean display_content_info; /* shall the number of messages be displayed? */
	argument BOOL show_content_info
		get { ARG = self->display_content_info; }
		set { self->display_content_info = ARG; balsa_mblist_rebuild( self ); };

	init( self ) {
		char *titles[3] = { N_("Mailbox"), N_("Unread"), N_("Total") };
		cfg_location_t *uiroot;

		titles[0] = _(titles[0]);
		titles[1] = _(titles[1]);
		titles[2] = _(titles[2]);

		#ifdef BALSA_SHOW_INFO
			gtk_ctree_construct (GTK_CTREE (self), 3, 0, titles);
		#else
			gtk_ctree_construct (GTK_CTREE (self), 1, 0, titles);
		#endif

		#ifdef BALSA_SHOW_INFO
		if (self->display_content_info)
			gtk_clist_column_titles_show (GTK_CLIST (self));
		else
		#endif
			/* we want this on by default */
			gtk_clist_column_titles_hide (GTK_CLIST (self));

		gtk_ctree_set_show_stub (GTK_CTREE (self), FALSE);
		gtk_ctree_set_line_style (GTK_CTREE (self), GTK_CTREE_LINES_DOTTED);
		gtk_ctree_set_expander_style (GTK_CTREE (self), GTK_CTREE_EXPANDER_SQUARE);
		gtk_clist_set_row_height (GTK_CLIST (self), 16);

		uiroot = cfg_memory_default_root();
		#ifdef BALSA_SHOW_INFO
			cfg_memory_add_to_clist( GTK_WIDGET( self ), uiroot, "MBList", 3, 40, 20, 30 );
		#else
			cfg_memory_add_to_clist( GTK_WIDGET( self ), uiroot, "MBList", 1, 90 );
		#endif
		cfg_location_free( uiroot );

		#ifdef BALSA_SHOW_INFO
		gtk_clist_set_column_justification (GTK_CLIST (self), 1, GTK_JUSTIFY_RIGHT);
		gtk_clist_set_column_justification (GTK_CLIST (self), 2, GTK_JUSTIFY_RIGHT);

		gtk_clist_set_sort_column (GTK_CLIST (self),0);
		gtk_clist_set_sort_type (GTK_CLIST (self), GTK_SORT_ASCENDING);
		gtk_clist_set_compare_func (GTK_CLIST (self), NULL);

		if (!self->display_content_info) {
			gtk_clist_set_column_visibility (GTK_CLIST (self), 1, FALSE);
			gtk_clist_set_column_visibility (GTK_CLIST (self), 2, FALSE);
		}
		#endif

		balsa_mblist_rebuild( self );
	}

	signal last
	NONE( POINTER, INT, POINTER )
	void select_mailbox( self, Mailbox *mailbox, gint row, GdkEventButton *button )
	{
	}

	override (Gtk:CTree)
	void tree_expand( Gtk:CTree *self, GtkCTreeNode *node )
	{
		MailboxNode *mbnode;

		PARENT_HANDLER( self, node );
  
		mbnode = gtk_ctree_node_get_row_data( GTK_CTREE(self), GTK_CTREE_NODE(node) );
		mbnode->expanded = TRUE;
	}

	override (Gtk:CTree)
	void tree_collapse( Gtk:CTree *self, GtkCTreeNode *node )
	{
		MailboxNode *mbnode;

		PARENT_HANDLER( self, node );
  
		mbnode = gtk_ctree_node_get_row_data( GTK_CTREE(self), GTK_CTREE_NODE(node) );
		mbnode->expanded = FALSE;
	}

	override (Gtk:CTree)
	void tree_select_row( Gtk:CTree *self, GtkCTreeNode *row, gint column )
	{
		GdkEventButton *bevent = (GdkEventButton *) gtk_get_current_event ();
		MailboxNode *mbnode;

		PARENT_HANDLER( self, row, column );

		mbnode = gtk_ctree_node_get_row_data( self, row );
		g_return_if_fail( mbnode != NULL );

		if (mbnode->IsDir || !BALSA_IS_MAILBOX(mbnode->mailbox))
			return;

		if (bevent && bevent->button == 1 && mbnode->mailbox) {
			gtk_signal_emit( GTK_OBJECT(self),
				object_signals[SELECT_MAILBOX_SIGNAL],
				mbnode->mailbox,
				row,
				bevent);
		}

	}

	override (Gtk:Widget)
	gint button_press_event( Gtk:Widget *self, GdkEventButton *event )
	{
		gint row, column;
		GtkCTreeNode *ctrow;
		MailboxNode *mbnode;

		PARENT_HANDLER( self, event );

		if( !event || event->button != 3 )
			return TRUE;

		if( event->button == 1 && event->type == GDK_2BUTTON_PRESS ) {
			gtk_clist_get_selection_info( GTK_CLIST(self), event->x, event->y, &row, &column );
			ctrow = gtk_ctree_node_nth( GTK_CTREE(self), row );
			mbnode = gtk_ctree_node_get_row_data( GTK_CTREE(self), ctrow );
			gtk_ctree_select( GTK_CTREE(self), ctrow );

			if( mbnode->IsDir )
				return TRUE;

			if( mbnode->mailbox && BALSA_IS_MAILBOX( mbnode->mailbox ) ) {
				gtk_signal_emit( GTK_OBJECT( self ),
					 object_signals[SELECT_MAILBOX_SIGNAL],
					 mbnode->mailbox,
					 ctrow,
					 event );
			}
		}

		return TRUE;
	}

	override (Gtk:CList)
	void click_column( Gtk:CList *self, gint column )
	{
		PARENT_HANDLER( self, column );

		#ifdef BALSA_SHOW_INFO
		if( self->sort_column == column ) {
			if( self->sort_type == GTK_SORT_DESCENDING )
				gtk_clist_set_sort_type( self, GTK_SORT_ASCENDING );
			else
				gtk_clist_set_sort_type( self, GTK_SORT_DESCENDING );
		} else {
			gtk_clist_set_sort_column( self, column );
			gtk_clist_set_sort_type( self, GTK_SORT_ASCENDING );
		}

		if( column == 0 )
			gtk_clist_set_compare_func( self, NULL );
		else
			gtk_clist_set_compare_func( self, numeric_compare );

		gtk_ctree_sort_recursive( GTK_CTREE(self), NULL );
		#endif
	}

	public
	Gtk:Widget *new( void )
	{
		return GTK_WIDGET( GET_NEW );
	}

	public
	void insert_mailbox( self, Mailbox *mailbox (check null), BalsaIconName icon )
	{
		GtkCTreeNode *ctnode;
		MailboxNode *mbnode;
		gchar *text[3];

		text[0] = mailbox->name;
		/* If no show_info, no harm done here */
		text[1] = "";
		text[2] = "";

		ctnode = gtk_ctree_insert_node( GTK_CTREE(self),
			NULL, NULL, text, 4,
			balsa_icon_get_pixmap( icon ),
			balsa_icon_get_bitmap( icon ),
			NULL, NULL,
			TRUE, FALSE );

		mbnode = mailbox_node_new( mailbox->name, mailbox, FALSE );

		gtk_ctree_node_set_row_data_full( GTK_CTREE(self), 
			ctnode, mbnode,
			(GtkDestroyNotify) mailbox_node_destroy );
	}

	public 
	void rebuild( self ) 
	{
		GtkCTree *ctree; 
		GtkCList *clist;

		ctree = GTK_CTREE( self );
		clist = GTK_CLIST( self );

		gtk_clist_freeze( clist );
		gtk_clist_clear( clist );

		#ifdef BALSA_SHOW_INFO
		if( self->display_content_info ) {
			gtk_clist_column_titles_show( clist );
			gtk_clist_set_column_visibility( clist, 1, TRUE );
			gtk_clist_set_column_visibility( clist, 2, TRUE );
		} else {
			gtk_clist_column_titles_hide( clist );
			gtk_clist_set_column_visibility( clist, 1, FALSE );
			gtk_clist_set_column_visibility( clist, 2, FALSE );
		}
		#endif

		balsa_mblist_insert_mailbox( self, balsa_app.inbox, BALSA_ICON_INBOX );
		balsa_mblist_insert_mailbox( self, balsa_app.outbox, BALSA_ICON_OUTBOX );
		balsa_mblist_insert_mailbox( self, balsa_app.sentbox, BALSA_ICON_TRAY_EMPTY );
		balsa_mblist_insert_mailbox( self, balsa_app.draftbox, BALSA_ICON_TRAY_EMPTY );
		balsa_mblist_insert_mailbox( self, balsa_app.trash, BALSA_ICON_TRASH );

		if( balsa_app.mailbox_nodes ) {
			GNode *walk;
			GtkCTreeNode *node;

			for( walk = g_node_last_child( balsa_app.mailbox_nodes ); walk; walk = walk->prev ) {
				node = gtk_ctree_insert_gnode( ctree, NULL, NULL, walk, mailbox_nodes_to_ctree, NULL );
				gtk_ctree_node_set_text( ctree, node, 1, "" );
				gtk_ctree_node_set_text( ctree, node, 2, "" );

			}
		}

		gtk_ctree_sort_recursive( ctree, NULL );
		balsa_mblist_have_new( self );
		gtk_clist_thaw( clist );
	}

	public 
	void set_style( self ) 
	{
		GdkColor color;
		GdkFont  *font;
		GtkStyle *style;

		/* Get the base style the user is using */
		style = gtk_style_copy (gtk_widget_get_style (GTK_WIDGET (self)));

		/* Attempt to set the font to bold */
		font = get_bold_font (GTK_WIDGET (self));
		gdk_font_unref (style->font);
		style->font = font; /*Now refed in get_bold_font*/

		/* Get and attempt to allocate the colour */
		color = balsa_app.mblist_unread_color;
		if (!gdk_colormap_alloc_color (gdk_colormap_get_system (), 
			&color, FALSE, TRUE)) 
		{
			g_warning( "Couldn't allocate colour for unread mailboxes!" );
			gdk_color_black (gdk_colormap_get_system(), &color);
		}

		/* Just put it in the normal state for now */
		style->fg[GTK_STATE_NORMAL] = color;

		/* Unref the old style (if it's already been set, and point to the
		 * new style */

		if (self->_priv->unread_mailbox_style != NULL)
			gtk_style_unref (self->_priv->unread_mailbox_style);
		self->_priv->unread_mailbox_style = style;
	}

	public 
	void have_new( self )
	{
		balsa_mblist_set_style( self );

		gtk_clist_freeze( GTK_CLIST( self ) );
		gtk_ctree_post_recursive( GTK_CTREE(self), NULL, 
			check_new, NULL );
		gtk_ctree_post_recursive( GTK_CTREE(self), NULL, 
			folder_style, NULL );
		gtk_clist_thaw( GTK_CLIST(self) );
	}

	public
	void update_mailbox( self, Mailbox *mailbox (check null) ) {
		GtkCTreeNode *node;
		gchar *desc;

		/* try and find the mailbox in both sub trees */
		node = gtk_ctree_find_by_row_data_custom( GTK_CTREE( self ), NULL,
			mailbox, mblist_mbnode_compare );

		if( node == NULL )
			return;

		/* Set the style for the next batch of formatting */
		balsa_mblist_set_style( self );

		/* We want to freeze here to speed things up and prevent ugly
		 * flickering */
		gtk_clist_freeze( GTK_CLIST( self ) );

		mailbox_style( GTK_CTREE( self ),
			node, 
			gtk_ctree_node_get_row_data( GTK_CTREE(self), node ),
			self->display_content_info );

		/* Do the folder styles as well */
		gtk_ctree_post_recursive( GTK_CTREE(self), NULL, 
			folder_style, NULL );

		gtk_clist_thaw( GTK_CLIST( self ) );

		/* moving selection to the respective mailbox.
		 * this is neccessary when the previous mailbox was closed and
		 * redundant if the mailboxes were switched (notebook_switch_page)
 		 * or the mailbox is checked for the new mail arrival
		 */

		if( gtk_ctree_node_nth( GTK_CTREE(self), GTK_CLIST(self)->focus_row ) != node ) {
			gtk_ctree_select( GTK_CTREE(self), node ); 
 
			if( gtk_ctree_node_is_visible( GTK_CTREE(self), node ) != GTK_VISIBILITY_FULL )
				gtk_ctree_node_moveto( GTK_CTREE(self), node, 0, 1.0, 0.0 );
		}

		desc = g_strdup_printf(_("Shown mailbox: %s with %ld messages, %ld new"), 
			mailbox->name, mailbox->total_messages,
			mailbox->unread_messages );
		gnome_appbar_set_default( balsa_app.appbar, desc );
		g_free( desc );
	}

}

%{ 

/* mailbox_nodes_to_ctree
 * 
 * Description: For adding GNodes to the mailbox list, also does
 * checking for new messages.
 * */

static gboolean
mailbox_nodes_to_ctree (GtkCTree * ctree,
			guint depth,
			GNode * gnode,
			GtkCTreeNode * cnode,
			gpointer data)
{
	MailboxNode *mbnode = NULL;
	gchar *name = NULL;
	GdkPixmap *closed_pmap = NULL;
	GdkBitmap *closed_bmap = NULL;
	GdkPixmap *open_pmap = NULL;
	GdkBitmap *open_bmap = NULL;
	gboolean expanded = FALSE;

	if( !gnode || ((mbnode = gnode->data) == NULL) )
		return FALSE;

	if( mbnode->mailbox ) {
		mbnode->IsDir = FALSE;

		if( mbnode->mailbox->type == MAILBOX_POP3 )
			return FALSE;

		name = mbnode->mailbox->name;	
		open_pmap = NULL;
		open_bmap = NULL;

		if( mbnode->mailbox->type == MAILBOX_IMAP ) {
			closed_pmap = NULL;
			closed_bmap = NULL;
			expanded = FALSE;
		} else if( mbnode->mailbox->type == MAILBOX_MH ||
			   mbnode->mailbox->type == MAILBOX_MAILDIR ) 
		{
			closed_pmap = balsa_icon_get_pixmap( BALSA_ICON_TRAY_EMPTY );
			closed_bmap = balsa_icon_get_bitmap( BALSA_ICON_TRAY_EMPTY );
			expanded = mbnode->expanded;
		} else if( mailbox_have_new_messages( MAILBOX( mbnode->mailbox) ) ) {
			mbnode->mailbox->has_unread_messages = TRUE;

			closed_pmap = balsa_icon_get_pixmap( BALSA_ICON_TRAY_FULL );
			closed_bmap = balsa_icon_get_bitmap( BALSA_ICON_TRAY_FULL );
			expanded = FALSE;
		} else {
			closed_pmap = balsa_icon_get_pixmap( BALSA_ICON_TRAY_EMPTY );
			closed_bmap = balsa_icon_get_bitmap( BALSA_ICON_TRAY_EMPTY );
			expanded = FALSE;
		}

	} else if( mbnode->name ) { /* Mailbox containing dir */
		name = g_basename( mbnode->name );
		closed_pmap = balsa_icon_get_pixmap( BALSA_ICON_DIR_CLOSED );
		closed_bmap = balsa_icon_get_bitmap( BALSA_ICON_DIR_CLOSED );
		open_pmap = balsa_icon_get_pixmap( BALSA_ICON_DIR_OPEN );
		open_bmap = balsa_icon_get_bitmap( BALSA_ICON_DIR_OPEN );
		expanded = mbnode->expanded;

		/* Make sure this gets set */
		mbnode->IsDir = TRUE;
		gtk_ctree_node_set_selectable( ctree, cnode, FALSE );
	}

	gtk_ctree_set_node_info( ctree, cnode,
		name, 5,
		closed_pmap, closed_bmap,
		open_pmap, open_bmap,
		G_NODE_IS_LEAF( gnode ),
		expanded );
	gtk_ctree_node_set_row_data( ctree, cnode, mbnode );
	return TRUE;
}

/* check_new [MBG]
 * (GtkCTreeFunc)
 *
 * ctree:The ctree that contains the mailbox nodes
 * node:  The node that is currently being called by the recursion
 * data:  The data that was passed on by the gtk_ctree_(pre|post)_recursive
 *
 * Description: This function is meant to be called as a part of a
 * recursive call gtk_ctree_(pre|post)_recursive, to traverse through
 * the tree and change the fonts of any mailboxes that have at least
 * one new message. It currently calls mailbox_check_new_messages on
 * the mailbox, but this may change.
 * */
static void
check_new (GtkCTree *ctree, GtkCTreeNode *node, gpointer data)
{
	MailboxNode *cnode_data;
	Mailbox *mailbox;

	/* Get the mailbox */
	cnode_data = gtk_ctree_node_get_row_data( ctree, node );

	/* If it's a directory or not a mailbox, we don't want to go any
	 * further */
	if( cnode_data->IsDir || !BALSA_IS_MAILBOX( cnode_data->mailbox ) )
		return;

	mailbox = BALSA_MAILBOX( cnode_data->mailbox );

	/* If it's not local the mail-check function won't work, and if it's
	 * already open we can get conflicting results since we're checking
	 * the file on disk as opposed to the mailbox in memory */

	mailbox->has_unread_messages = mailbox_have_new_messages( mailbox );

	mailbox_style( ctree, node, cnode_data, BALSA_MBLIST(ctree)->display_content_info );
}

/* mailbox_style [MBG]
 * 
 * ctree:  The ctree containing the mailbox
 * node:  The ctreenode that is associated with the mailbox
 * mailbox:  The mailbox that is to have it's style changed
 * display_info:  whether or not to display the columns
 * 
 * Description: A function to actually do the changing of the style,
 * and is called by both balsa_mblist_update_mailbox, and
 * balsa_mblist_check_new, hence the (slightly) strange arguments.
 * */
static void 
mailbox_style (GtkCTree * ctree, GtkCTreeNode *node, MailboxNode *mbnode, gboolean display_info )
{
	BalsaMBList* mblist;
	Mailbox* mailbox;
	GtkStyle* style;
	BalsaIconName icon;
	gboolean tmp_is_leaf, tmp_expanded;
#ifdef BALSA_SHOW_INFO
	gchar *text;
#endif
	
	if (node == NULL)
		return;
	
	mblist = BALSA_MBLIST (ctree);
	mailbox = mbnode->mailbox;
	
#ifdef BALSA_SHOW_INFO
	/* If we have a count of the unread messages, and we are showing
	 * columns, put the number in the unread column.
	 * We can only collect exact info about a mailbox's contents
	 * if we open it, which we don't like doing, so don't display
	 * anything if content info is unknown.
	 */
	if( display_info && mailbox->open_ref ) {
		text = g_strdup_printf ("%ld", mailbox->unread_messages);
		gtk_ctree_node_set_text (ctree, node, 1, text);
		g_free(text);
		
		text = g_strdup_printf ("%ld", mailbox->total_messages);
		gtk_ctree_node_set_text (ctree, node, 2, text);
		g_free(text);
		
		mbnode->style |= (MBNODE_STYLE_UNREAD_MESSAGES | MBNODE_STYLE_TOTAL_MESSAGES);
	}
#endif
    
	if (mailbox->has_unread_messages) {
    
		/* set the style of the unread maibox list, even if it's already 
		 * set... in case the user has changed the colour or font since the
		 * last style update */    
		gtk_ctree_node_set_row_style (ctree, node, mblist->_priv->unread_mailbox_style);
		
		tmp_is_leaf = GTK_CTREE_ROW (node)->is_leaf;
		tmp_expanded = GTK_CTREE_ROW (node)->expanded;
    
		if (mailbox == balsa_app.trash)
			icon = BALSA_ICON_TRASH;
		else
			icon = BALSA_ICON_TRAY_FULL;
		
		gtk_ctree_set_node_info (ctree, node, mailbox->name, 5,  
					 balsa_icon_get_pixmap (icon),
					 balsa_icon_get_bitmap (icon),
					 NULL, NULL, tmp_is_leaf, tmp_expanded);
      
		mbnode->style |= MBNODE_STYLE_ICONFULL;
    
	} else {
		/* If the clist entry currently has the unread messages icon, set
		 * it back, otherwise we can ignore this. */
		if (mbnode->style & MBNODE_STYLE_ICONFULL) {
			style = gtk_widget_get_style (GTK_WIDGET (ctree));
			gtk_ctree_node_set_row_style (ctree, node, style);

			/* this unref is not needed, since the style is unref'd in */
			/* gtk_ctree_node_set_row_style, and we have made no additional */
			/* ref's of our own */
			/*  gtk_style_unref (style); */
      
			tmp_is_leaf = GTK_CTREE_ROW (node)->is_leaf;
			tmp_expanded = GTK_CTREE_ROW (node)->expanded;
      
			if (mailbox == balsa_app.inbox) {
				icon = BALSA_ICON_INBOX;
			} else if (mailbox == balsa_app.outbox) {
				icon = BALSA_ICON_OUTBOX;
			} else if (mailbox == balsa_app.trash) {
				icon = BALSA_ICON_TRASH;
			} else {
				icon = BALSA_ICON_TRAY_EMPTY;
			}
      
			 gtk_ctree_set_node_info (ctree, node, mailbox->name, 5,  
						 balsa_icon_get_pixmap (icon),
						 balsa_icon_get_bitmap (icon),
						 NULL, NULL, tmp_is_leaf, tmp_expanded);
			
			mbnode->style &= ~MBNODE_STYLE_ICONFULL;
		}
	}
}

/* folder_style [MBG]
 * 
 * Description: This is meant to be called as a post recursive
 * function after the mailbox list has been updated style wise to
 * reflect the presence of new messages.  This function will attempt
 * to change the style of any folders to appropriately reflect that of
 * it's sub mailboxes (i.e. if it has one mailbox with unread messages
 * it will be shown as bold.
 * */
static void 
folder_style (GtkCTree* ctree, GtkCTreeNode* node, gpointer data)
{
	BalsaMBList* mblist;
	MailboxNode* mbnode;
	GtkCTreeNode* parent;
	GtkStyle* style;
	static guint32 has_unread;

	parent = GTK_CTREE_ROW (node)->parent;
	mbnode = gtk_ctree_node_get_row_data (ctree, node);
	mblist = BALSA_MBLIST (ctree);

	/* If we're on a leaf, just see if it's displayed as unread */
	if (GTK_CTREE_ROW (node)->is_leaf && !(mbnode->IsDir)) {
		if (mbnode->style & MBNODE_STYLE_ICONFULL) 
			has_unread |= 1 << (GTK_CTREE_ROW (node)->level);
		return;
	} else {
		if (!mbnode->IsDir)
			return;

		/* We're on a folder here, see if any of the leaves were displayed
		 * as having unread messages, change the style accordingly */
		if (has_unread & (1 << (GTK_CTREE_ROW (node)->level + 1))) {
			gtk_ctree_node_set_row_style (ctree, node, mblist->_priv->unread_mailbox_style);

			mbnode->style |= MBNODE_STYLE_ICONFULL;

			/* If we've reached the top of the tree, reset the counter for
			 * the next branch */
			if (parent == NULL) {
				has_unread = 0;
			} else {
				has_unread |= (1 << (GTK_CTREE_ROW (node)->level));
				has_unread &= ~(1 << (GTK_CTREE_ROW (node)->level + 1));
			}

			return;
		} else if (mbnode->style & MBNODE_STYLE_ICONFULL) {
			/* This folder's style needs to be reset to the vanilla style */
			style = gtk_widget_get_style (GTK_WIDGET (ctree));
			gtk_ctree_node_set_row_style (ctree, node, style);
			/* this unref is not needed, since the style is unref'd in
			 * gtk_ctree_node_set_row_style, and we have made no additional
			 * ref's of our own 
		 	 */
			/*gtk_style_unref (style); */

			mbnode->style &= ~MBNODE_STYLE_ICONFULL;
			return;
		}
	}
}

#ifdef BALSA_SHOW_INFO                

/* numeric_compare [MBG]
 * 
 * Description: this is for sorting mailboxes by number of unread or
 * total messages.
 * */

static gint
numeric_compare (GtkCList * clist, gconstpointer ptr1, gconstpointer ptr2)
{
	MailboxNode* mb1;
	MailboxNode* mb2;
	Mailbox* m1;
	Mailbox* m2;
	glong t1, t2;

	GtkCListRow *row1 = (GtkCListRow *) ptr1;
	GtkCListRow *row2 = (GtkCListRow *) ptr2;

	mb1 = row1->data;
	mb2 = row2->data;

	m1 = mb1->mailbox;
	m2 = mb2->mailbox;

	if (!m1 || !m2)
		return 0;

	if (clist->sort_column == 1) {
		t1 = m1->unread_messages;
		t2 = m2->unread_messages;

		if (t1 < t2)
			return 1;
		if (t1 > t2)
			return -1;
	} else if (clist->sort_column == 2) {
		t1 = m1->total_messages;
		t2 = m2->total_messages;

		if (t1 < t2)
			return 1;
		if (t1 > t2)
			return -1;
	}

	return 0;
}
#endif

/* mblist_mbnode_compare [MBG]
 *   (GtkCTreeCompareFunc)
 * 
 * Description: This is for finding a mailbox within a mailbox list.
 * */
static gint
mblist_mbnode_compare (gconstpointer a, gconstpointer b)
{
	MailboxNode *mbnode = (MailboxNode *) a;
	Mailbox *mailbox = (Mailbox *) b;

	if (mailbox == mbnode->mailbox)
		return 0;
	else
		return 1;
}

/* get_bold_font [MBG]
 * 
 * Description: This function takes a widget and returns a bold
 * version of font that it is currently using.  If it fails, it simply
 * returns the default font of the widget.  ** This function references
 * the fonts now (change of behavior) ** 
 * */
static GdkFont* 
get_bold_font (GtkWidget* widget)
{
	gchar* new_xlfd;
	gchar* old_xlfd;
	gchar** temp_xlfd;
	GdkFont* font;
	GtkStyle* style;
	GSList* list;

	style = gtk_widget_get_style (widget);
	font = style->font;

	/* Get the current font XLFD */
	list = ((GdkFontPrivate*)font)->names;
	old_xlfd = (gchar*)list->data;

	/* Split the XLFD into its components */
	temp_xlfd = g_strsplit (old_xlfd, "-", 14);

	/* Change the weight to bold */
	g_free (temp_xlfd[3]);
	temp_xlfd[3] = g_strdup ("bold");

	/* Reassemble the XLFD */
	new_xlfd = g_strjoinv ("-", temp_xlfd);
	g_strfreev (temp_xlfd);

	/* Try to load it, if it doesn't succeed, re-load the old font */
	font = gdk_font_load (new_xlfd);
	g_free (new_xlfd);

	if (font == NULL) {
		font = gdk_font_load (old_xlfd);

		if (font == NULL) {
			font = style->font;
		}
	}

	gdk_font_ref( font );
	return font;
}

%}